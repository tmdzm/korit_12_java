# 

## catch 상에서의 sout vs. throw new

catch 블록 내에서 sout을 쓰는 것과 다시 예외를 던지는(throw new) 것의 차이는, 내부에서 문제를 해결할 것인가 vs. 상위 메서드에게 보고를 할 것인가라고 비유할 수 있습니다.


1. System.out.println - 예외처리 후 소멸
    - 여기서 문제 해결을 다 했고, 프로그램을 진행하라는 의미


```java
try {
    int result = 10 / 0 ;
} catch (ArithmeticException e) {
    System.out.println("0으로 나눌 수 없습니다.");  // 이거 띄워놓고
}
System.out.println("이 뒷부분이 계속 실행이 됩니다.");  // catch 바깥의 코드들이 실행됨.

```

2. throw new (예외 재발생 - 전파)
- 예외 처리 자체가 불가능 하다, 혹은 해당 사실을 상위 메서드에 전달해줘야 한다는 의미
    1. 목적 : 예외를 '다시' 발생 시켜 상위 메서드(호출한 곳)로 예외를 전달하는 것.
    2. 현재 메서드는 즉시 중단되며, 상위 메서드에서 다시 try - catch로 잡아내거나, 또 throw로 던지는 형태.

```java
try{
    int result = 10/0;
} catch(ArithmeticException e){
    System.out.println("아까처럼 기록하는 부분 :  0 으로 나누기가 콘솔에 찍힙니다.");
    throw new RuntimeException("심각한 오류 발생 - 상위 메소드에서 처리");
}
System.out.println("이건 실행 안된다.");

```

# Lambda Expression(람다식)

## 정의
Java 8 도입된 함수형 프로그래밍 스타일을 Java에 적용한 것으로 메서드를 하나의 식으로 표현한것을 의미함.

- 원래는 익명함수라 부른다. 기존의 Java에서는 메서드 하나를 만들기 위해 반드시 클래스르 만들고 객체를 생성해야하지만<br>
람다식은 다르다.

## 문법 구조
기존 메서드에서 메서드명과 return 타입을 제거하고 '->'를 사용한다.(JS에선 =>)
'(매개변수) -> {실행문}'

## 코드 예시
- 예를 들어 두 수 중 더 큰 숫자를 return하는 메서드를 정의한다고 해보자
1. 기존 코드
```java
Comparator<Integer> comp = new Comparator<>(){
    @Override
    public int compare(Integer a, Integer b){
        return a.compareTo(b);
    }
}

public class Temp{
    public int returnMax(int a, int b){
        int result = a > b ? a : b;
        return result;
    }
}

```

2. lambda 식 적용
```java
Comparator<Integer> comp(a,b) -> a.compareTo(b);

```

## 람다식을 사용하는 이유
1. 코드 간결성
2. 컬렉션 활용의 극대화
    - SpringBoot에서 Security 관련에서 자주 쓰겠지만 원래는 Collection과 관련된 Stream API와 결합했을 때 큰 효과를 가진다.<br>
    배열이나 리스트의 데이터를 필터링하거나 변환할때 for/if문을 줄일 수 있다.

List에서 짝수만 출력하는 경우
```java
    nums.stream().filter(n->n%2==0).forEach(System.out::println);
```

3. 병렬 처리의 용이성
    - 람다식을 사용하면 개발자가 직접 스레드를 관리하지 않아도 Java내에서 데이터를 나누어 여러 cpu에서 동시에 처리하기 쉬운 구도가 된다.

## 함수형 인터페이스(제한)
- 람다식 자체는 아무데나 쓸 수 있는 것은 아니고 '딱 하나의 추상 메서드만 가진 인터페이스' 에서만 사용할 수 있다.<br>
이를 함수형 인터페이스(@FunctionalInterface) 라고 한다.

## 람다식 문법 생략 규칙
- 매개변수 타입 생략 : 인터페이스 내에 자료형이 정의되어 있으므로 생략 가능
    - '(int a) -> {...}' -> '(a) -> {...}'
- 매개변수가 하나라면 괄호 생략가능
    - a->{...}
- 실행문이 한줄이면 {}와 return 문구 생략 가능
    - 'a -> {return a*a;}' -> 'a -> a*a';

## 자주 사용되는 Stream API
1. Filter
    - 데이터 중에서 특정 조건에 맞는 것만 고르는 역할
        - 특징 : 결과 데이터의 개수가 줄어들 수 있지만, 데이터의 자료형은 변경 x
        - 코드 예시 : 's-> s>= 60' 점수가 60점 이상인것만 통과

2. Map
    - 데이터를 다른 값이나 형태로 바꾸는 역할
    - 특징 : 데이터의 개수는 원본과 동일하지만 , 데이터의 값이나 자료형이 변경될 수 있음
    - 코드 예시 : 's->s+5' 각 s에 +5한 결과값이 도출
    
3. Sorted
    - 데이터를 특정 기준에 따라서 순서대로 나열하는 역할
        - 특징 : 데이터의 내용이나 개수는 벼ㅑㄴ하지 않고 오직 순서만 바뀜
        - 코드 예시 : Comparator.reverseOrder()

적용사례
```java
    List<Integer> scores = List.of(23,54,61,2,190);
        scores.stream()                             //1.Stream API 사용선언
                .filter(s->s>=60)            //2.60점 미만 거르기
                .map(s->s+5)                 //3.그 숫자에 5씩 더하기
                .sorted()                           //4.오름차순 정렬
                .forEach(System.out::println);
```

